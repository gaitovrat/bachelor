\chapter{Řízení modelu auta}
\label{sec:PlatformControl}\

V této kapitole je popsán způsob manuálního a automatického řízení. Pro automatické
řízení je popsán způsob rozpoznání dráhy a řízení servo i motorů. Pro manuální
řízení je popsán způsob ovládaní auta pomocí RC ovladače. Přepínáni mezi režimy
bylo implementováno pomocí tlačítka A na POLI-TFC.

\section{Dráha}\

Testování řízení platformy bylo provedeno na dráze ve tvaru čísla 8.

Dráha je zobrazena na obrázku \ref{fig:Road}.

\begin{figure}[!h]
    \centering
    \includegraphics[width = .55\linewidth]{Figures/Road.png}
    \caption{Dráha.}
    \label{fig:Road}
    \vspace{-15pt}
\end{figure}

\section{Automatické řízení}\

\textbf{Automatické řízení} se skládá ze dvou častí. První je algoritmus rozpoznání drahý pomocí řádkové kamery. Druhá je kontrola motoru a servo na základě těchto dat. Implementace řízení je inspirovaná bakalářskou práce Zvonka Richarda \uv{Mechanizmy řízení robotického auta NXP (FREESCALE)}.

\subsection{Rozpoznání dráhy}\

Nejprve bylo zapotřebí získat obraz, který zajišťuje řádková kamera. Pro formát dat
je použita třída TFC \cite{draha}, která vrací data ve formátu 1D pole typu uint16\_t
(16bitové celá čísla bez znaménka) v intervalu <0; 4095>.

Obraz se zpracovává v následujících krocích:
\begin{enumerate}
    \item Filtrování mediánem;
    \item Normalizace obrazu;
    \item Prahování průměrem.
\end{enumerate}

\subsubsection*{Filtrování mediánem}\

\textbf{Filtrování mediánem} je užitečné pro odstranění malých artefaktů v obraze.
Zpracování pixelů probíhá na základě jeho okolních pixelů. Je zapotřebí tak mít
uloženy všechny pixely. Každá hodnota pixelu je nahrazena mediánem hodnot v určitém
okolí daného pixelu, což pomáhá zachovat ostré hrany obrazu, zatímco šum je
redukován. Ukázka použitého algoritmu je ve výpisu \ref{lst:slowMedianBlur} \cite{draha}\cite{robot}.

\begin{lstlisting}[caption = Filtrování mediánem, label = lst:slowMedianBlur]
// Image.cpp
void Image::slowMedianBlur(RefCImageLine srcImg, RefImageLine dstImg,
                           int pixels) {
    memcpy(dstImg, srcImg, LINE_LENGTH);
    std::vector<uint16_t> blurBuffer;

    for (int i = pixels; i < LINE_LENGTH - pixels; i++) {
        for (int j = -pixels; j <= pixels; j++) {
            blurBuffer.emplace_back(srcImg[i - j]);
        }
        std::sort(blurBuffer.begin(), blurBuffer.end());
        dstImg[i] = blurBuffer.at(pixels + 1);
        blurBuffer.clear();
    }
}
\end{lstlisting}


\subsubsection*{Normalizace obrazu}\

\textbf{Normalizace obrazu} probíhá na základě nalezení minimálního a maximálního
bodu v celém obraze. Každý bod je normalizován v intervalu <min; max> do intervalu
<0; 255>.

Díky normalizaci obrazu je auto schopno se přizpůsobit k různým  podmínkám. Použitý
algoritmus normalizace je ve výpisu \ref{lst:normalize} \cite{robot}.
\begin{lstlisting}[caption = Normalizace obrazu, label = lst:normalize]
// Image.cpp
void Image::normalize(RefCImageLine srcImg, RefImageLine dstImg) const {
    for (int i = 0; i < LINE_LENGTH; i++) {
        auto pixel = static_cast<float>(srcImg[i]);
        pixel -= this->minValue;
        pixel *= COLOR_WHITE;
        pixel /= (this->maxValue - this->minValue);
        dstImg[i] = static_cast<uint16_t>(pixel);
    }
}
\end{lstlisting}

\subsubsection*{Prahování průměrem}\

Pomocí prahování se obraz převádí do binárního formátu (formát, který se skládá
pouze ze~dvou hodnot (0, 1)). Zapotřebí je tak určit hodnotu prahu pro každý pixel.
Pokud pixel je nižší než práh, je nastaven na 0, jinak je nastaven na 1 nebo 255.
Ukázku algoritmu je ve výpisu \ref{lst:threshold} \cite{robot}.
\begin{lstlisting}[caption = Prahování průměrem, label = lst:threshold]
// Image.cpp
void Image::threshold(RefCImageLine srcImg, RefImageLine dstImg) const {
    for (int i = 0; i < LINE_LENGTH; i++) {
        if (srcImg[i] < this->threshValue)
            dstImg[i] = COLOR_BLACK;
        else
            dstImg[i] = COLOR_WHITE;
    }
}
\end{lstlisting}

\subsection{Kontrola servomotoru}\

Pro kontrolu pozice servomotoru je použit \textbf{PID regulátor}. PID reguluje
zařízení tak, aby odchylka byla od nastavené hodnoty co nejmenší. Skládá se ze 3
složek: proporcionální, integrační, derivatiční \cite{PID}.

Pro proporcionální složku se používá rozdíl poměru vzdálenosti čar od okrajů obrazu.
\begin{lstlisting}[caption = Kalkulace poměru vzdálenosti čar, label = lst:calculateDistanceRatio]
// Core.cpp
float Core::calculateDistanceRatio() {
    this -> tracer.addImage(data.line);

    std::pair<uint8_t, uint8_t> distances = tracer.getDistancesPair();

    data.leftDistance = distances.first;
    data.rightDistance = Shared::Image::LINE_LENGTH - distances.second;

    const float leftRatio = static_cast<float>(data.leftDistance) /
                            static_cast<float>(data.rightDistance);
    const float rightRatio = static_cast<float>(data.rightDistance) /
                             static_cast<float>(data.leftDistance);

    data.regionsCount =
        tracer.getRegions(data.line, 0, TFC_CAMERA_LINE_LENGTH - 1, false).size();
    data.regionsListSize = tracer.listSize_;
    data.unchangedLeft = tracer.unchangedLeft_;
    data.unchangedRight = tracer.unchangedRight_;
    data.hasLeft = tracer.hasLeft_;
    data.hasRight = tracer.hasRight_;

    return rightRatio - leftRatio;
}
\end{lstlisting}

Hledaní těchto čar je implementováno pomocí algoritmu pod názvem \uv{hledání
Regionu}, což je struktura, která uchovává indexy okrajů oblastí jedné barvy.
Algoritmus hledá regiony ve smyčce, která si uchovává barvy a porovná ji s barvou
samotného bodu. Jestliže se barva změnila, znamená to konec jednoho regionu a
začátek nového. Zmíněný algoritmus je zobrazen ve výpisu \ref{lst:getRegions} \cite{robot}.
\begin{lstlisting}[caption = Algoritmus hledání regionu, label = lst:getRegions]
// LineTracer.cpp
std::vector<Shared::Region> LineTracer::getRegions(const Shared::Image &image, uint8_t searchLeftIdx, uint8_t searchRightIdx, bool saveToClass ) {
	std::vector<Shared::Region> foundRegions;

	uint8_t currentColor = static_cast<uint8_t>(image.atThresh(searchLeftIdx));
	foundRegions.emplace_back(Shared::Region({searchLeftIdx, searchLeftIdx, currentColor}));

	for (uint8_t i = searchLeftIdx; i <= searchRightIdx; i++) {
		if (currentColor != image.atThresh(i)) {
			if (foundRegions.size() > MAX_REGIONS_COUNT) {
				break;
			}
			foundRegions.at(foundRegions.size() - 1).right = i;
			foundRegions.emplace_back(Shared::Region({i, i, image.atThresh(i)}));
		}
		currentColor = static_cast<uint8_t>(image.atThresh(i));
	}

	if(saveToClass){
		currentRegions_ = foundRegions;
	}

	return foundRegions;
}
\end{lstlisting}

\subsection{PWM řízení motorů}\

U řízení motorů musíme rozlišovat dvě fáze: \textbf{zatáčení} a \textbf{jízdu
rovně}. Pro rozpoznaní fázi zatáčení je použit algoritmus mediánu historie obrazu.
Aplikace si uchovává historii zpracovaných záznamů (regionů) a pro oba okraje je
vypočítán medián. Pokud se okraje aktuálního řídícího regionu nachází v blízkém
okolí vypočteného mediánu, auto se pravděpodobně nachází na rovině a oba motory se
mohou otáčet na maximálně nastavený výkon. Pokud jinak, auto se pravděpodobně
nachází v zatáčce a je tedy potřeba zpomalit motor na straně, kde se nachází okraj.
Zpomalení je implementováno na základě úhlu servomotoru. Algoritmus je ve výpisu \ref{lst:getRegions} \cite{robot}.
\begin{lstlisting}[caption = Algoritmus kontroly PWM motorů\cite{robot}, label = lst:controlPWM]
// Core.cpp
float speed = SPEED;
data.angle = (data.servoPosition * 5.85f / 200) * PI /
	                 180.f; // Convert servo to angle

if (!(this->tracer.unchangedLeft_ && this->tracer.unchangedRight_)) {
    innerSpeed =
        speed * (1.f - DIFF_COEF * (1.50f * tanf(data.angle)) / 2.f * 1.85f);
    outerSpeed =
        speed * (1.f + DIFF_COEF * (1.50f * tanf(data.angle)) / 2.f * 1.85f);

    if (data.angle > 0.f) {
        data.rightSpeed = innerSpeed;
        data.leftSpeed = outerSpeed;
    } else {
        data.leftSpeed = innerSpeed;
        data.rightSpeed = outerSpeed;
    }

    data.servoPosition *= 1.5f;
    data.leftSpeed *= 0.75f;
    data.rightSpeed *= 0.75f;
} else {
    data.leftSpeed = speed;
    data.rightSpeed = speed;
}
\end{lstlisting}

\section{Manuální řízení}\

Pro manuální řízení byl použit \textbf{vysílač HITEC OPTIC 6 SPORT}.
Vysílač zobrazen na~obrázku \ref{fig:Joystick}. HITEC OPTIC 6 SPORT posílá signál do přijímače Minima 6S. Oba pracují na
frekvenci 2,4~GHz. Ovladač má dvě páky. Jedna je použitá pro zvětšení a zmenšení
plynu motoru. Druhá je použitá pro změnu pozice servomotoru \cite{RC}.

Oba signály jsou přijímány přes kanály CH1 a CH2 \cite{RC}. Tyto kanály jsou
integrovány do modulu POLI-TFC shield, kde jsou signály zpracovány programově
prostřednictvím třídy TFC\cite{draha}. Hodnoty signálů se nacházejí v rozsahu
<1000; 2000>, Tyto hodnoty jsou následně transformovány do rozsahu <-1; 1> pomocí níže
uvedeného vzorce:

\begin{equation}
	\centering
	y = (x / 100 - 15) / 10,
\end{equation}

kde $y$ je normalizovaná hodnota a $x$ je hodnota z přijímače. Poté je $y$ násobeno
na maximální hodnotu PWM motorů nebo servomotoru. Výsledek je následně použit pro
jejich nastavení.

\begin{figure}[!h]
    \centering
    \includegraphics[width = .5\linewidth]{Figures/Joystick.png}
    \caption{Ovladač HITEC OPTIC 6 SPORT.}
    \label{fig:Joystick}
\end{figure}

\endinput
